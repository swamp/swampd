struct Datagrams

impl Datagrams {
    external 10 fn write(self, any: Any)
    external 11 fn id(self) -> Int
}

type UUID = [Byte; 16]
type UUID_VIEW = [Byte]

fn uuid_to_string(view: UUID_VIEW) -> String {
	mut s = ""
	for x in view {
		temp = x.string()

		next: String<2> = temp.slice(2..4)
		s = s + next
	}
	s
}

external 50 fn true_random() -> Int
external 51 fn generate_uuid() -> UUID_VIEW

struct Db

impl Db {
    external 500 fn new() -> Db

    /// Automatically serializes the struct value into a HSET with key value pairs
    /// Note: the value must be flat with basic field types
    external 501 fn set(mut self, name: String, any: Any)

    /// get is a HGETALL
    /// if it didn't exist it wil get all zeroed out
    external 502 fn get(mut self, key: String, any: Any)
    external 504 fn getset(mut self, key: String, any: Any) // overwrites!
	external 513 fn delete(mut self, key: String)


	external 505 fn lpush(mut self, key: String, value: String) // TODO: should support [String] for values
	external 506 fn rpush(mut self, key: String, value: String) // TODO: should support [String] for values
	external 507 fn lpop(mut self, key: String) -> String
	external 508 fn rpop(mut self, key: String) -> String
	external 509 fn rpoplpush(mut self, source: String, destination: String)
	external 510 fn lset(mut self, key: String, index: Int, data: String)
	external 511 fn llen(mut self, key: String) -> Int
	external 512 fn lrange(mut self, key: String, start: Int, stop: Int) -> [String]

	external 503 fn incr(mut self, key: String) -> Int
}
